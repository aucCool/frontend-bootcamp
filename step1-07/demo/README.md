# Шаг 1.7 - Типы и создание состояния, управляемого пользовательским интерфейсом (демонстрация)

Теперь, когда у нас есть пользовательский интерфейс, который зависит исключительно от состояния нашего приложения, нам нужно добавить функциональность, позволяющую пользовательскому интерфейсу управлять состоянием. Это часто делается путем создания функций, вызывающих "setState", как мы видели в "TodoHeader". Значения из состояния затем передаются дочерним компонентам в качестве реквизитов.

> В части 2 этого семинара мы узнаем, как мы можем раскрывать эти функции, не передавая их явно через реквизит.

Это наша основная "бизнес-логика", которая обрабатывает наши основные операции "CRUD": Создание, Чтение, Обновление, Удаление. У нас нет времени на написание всех этих функций, но вы можете видеть, что они уже включены в демонстрационное приложение " TodoApp` и переданы в наши компоненты.

## Вступление к TypeScript

Взглянув на наши компоненты в "TodoApp", вы можете увидеть, что наш список реквизитов становится не просто длиннее, но и намного сложнее! Мы проходим через функции с различными сигнатурами, сложными объектами "todos" и строками фильтров, которые всегда имеют одно из трех значений.

По мере роста приложений становится трудно запомнить, что делает каждая функция или что содержит каждое задание. Кроме того, поскольку JavaScript является динамически типизированным языком, если бы я хотел изменить значение "todos" на массив внутри моего "ToDoList", JavaScript было бы все равно. Но если бы "TodoListItems" ожидал объект, наше приложение сломалось бы.

По этим двум причинам отрасль переходит к написанию приложений с жесткой типизацией, и многие для этого используют TypeScript.

Как  [ веб-сайт TypeScript ](https://www.typescriptlang.org/) утверждает:

> TypeScript-это надмножество JavaScript, которое компилируется в обычный JavaScript.

Если вы использовали [Sass](http://sass-lang.com/), вы знакомы с этой концепцией. Точно так же, как весь допустимый CSS является допустимым Sass, весь допустимый JavaScript является допустимым TypeScript текстом. Вот почему наши упражнения были написаны в файлах " ts "и `tsx` вместо `js` и `jsx`.

Давайте погрузимся в это и посмотрим, как TypeScript может помочь прояснить наши компоненты и защитить от будущих регрессий.

# Демонстрация
Давайте начнем с ToDoList, так как в нем больше всего потоков данных вверх и вниз. В этом компоненте нет никакого интерактивного пользовательского интерфейса, так как мы просто передаем "завершено" каждому "Списку задач Todo", но мы можем написать интерфейс реквизита, чтобы убедиться, что все передается правильно.

## ## Написание Реквизита Для Списка Задач

Глядя на наше приложение "TodoApp", мы знаем, что "ToDoList" имеет три реквизита: "фильтр", "задачи" и "полный". Мы начнем с создания интерфейса под названием "Реквизиты списка дел", который представляет реквизиты этого компонента.
```ts
interface TodoListProps {
  filter: any;
  todos: any;
  complete: any;
}
```

> Обратите внимание, что сейчас мы используем ключевое слово " любой`. Это не даст нам никакой безопасности типов, но позволит нам указать допустимые имена, которые мы можем передать этому компоненту.

Написав этот интерфейс, мы добавим его в наш класс компонентов.

```ts
export class TodoList extends React.Component<TodoListProps, any>
```

> Обратите внимание, что первое значение в `<>` предназначено для интерфейса реквизита, а второе-для состояния.

Теперь, когда у нас есть типизированный компонент, давайте вернемся к нашему "TodoApp" и посмотрим, что произойдет, если мы попытаемся изменить имя реквизита.

## Добавление безопасности типов

До сих пор мы только установили, каковы наши имена реквизитов, а не тип значений внутри них. Давайте сначала рассмотрим "фильтр" и посмотрим, как мы можем улучшить типовую безопасность этой опоры.

### Тип фильтра

Мы знаем, что "фильтр" не должен быть объектом, массивом или функцией, поэтому мы можем указать, что он всегда должен быть такой строкой:

```ts
interface TodoListProps {
  filter: string;
  todos: any;
  complete: any;
}
```

Но поскольку мы знаем, что фильтр может быть только одним из трех значений, мы можем сделать это явным с помощью [union type](https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types):

```ts
interface TodoListProps {
  filter: 'all' | 'active' | 'completed';
  todos: any;
  complete: any;
}
```

Теперь попробуйте вернуться к "TodoApp" и изменить атрибут "фильтр" в "Списке дел" на что-то другое. Вы увидите ошибку в редакторе (при использовании VS-кода) и в командной строке при сохранении файла.

### Полный Тип

`Полная " опора-это не данные, а функция. К счастью, TypeScript может обрабатывать типы функций так же хорошо, как и данные.

```ts
interface TodoListProps {
  filter: 'all' | 'active' | 'completed';
  todos: any;
  complete: (id: string) => void;
}
```

Для функций нас интересуют только переданные параметры и возвращаемое значение. В приведенном выше примере вы можете видеть, что функция принимает "идентификатор" типа string и возвращает "void", что означает, что она не имеет возвращаемого значения.

> Технически, все функции в JavaScript возвращают "неопределенное", если не указано другое возвращаемое значение, но объявление возвращаемого типа "void" приводит к ошибке TypeScript, если вы пытаетесь вернуть значение из функции (или используете возвращаемое по умолчанию значение " неопределенное`).

## Тип Todos

Реквизит "todos` интересен тем, что" todos` - это объект с кучей неизвестных ключей. Итак, вот как будет выглядеть этот интерфейс.

```ts
interface TodoListProps {
  filter: 'all' | 'active' | 'completed';
  todos: {
    [id: string]: {
      label: string;
      completed: boolean;
    };
  };
  complete: (id: string) => void;
}
```

> Заметьте что  `[id: string]` не указывает массив; это  объект [index signature](https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types).

Теперь, когда наш интерфейс завершен, попробуйте изменить слово "все" в "фильтр === все" и убедитесь, что VS-код сообщит вам, что это условие всегда будет ложным. Сравните это с обычным JavaScript: если бы в этой строке была опечатка, вы бы не поняли, почему ваш фильтр не работал.

## Типы общего доступа

Большинству наших компонентов потребуется указать типы для "задач" и "фильтра", поэтому хорошо, что TypeScript позволяет нам обмениваться типами между файлами. Я уже написал и экспортировал эти общие типы в файл "TodoApp.types.ts", поэтому нам просто нужно импортировать их и использовать в нашем интерфейсе.

```ts
import { FilterTypes, Todos, CompleteTodo } from '../TodoApp.types';

interface TodoListProps {
  complete: CompleteTodo;
  todos: Todos;
  filter: FilterTypes;
}
```

## Написание Реквизита Элемента Списка Задач Todo

Переходя к TodoListItem, когда мы начинаем писать реквизит "Список дел", мы понимаем, что два из предложенных, "метка" и "завершено", уже определены в интерфейсе "TodoItem". Таким образом, мы можем заставить "Реквизит элемента списка дел" повторно использовать интерфейс "TodoItem", расширив его.

```ts
import { CompleteTodo } from '../TodoApp.types';

interface TodoListItemProps extends TodoItem {
  id: string;
  complete: CompleteTodo;
}
```

Конечным результатом этого является интерфейс со всеми четырьмя свойствами: "идентификатор", "завершенный", "завершено" и "метка".

Затем мы можем использовать оставшиеся реквизиты в функции рендеринга:
```jsx
const { label, completed, complete, id } = this.props;
```

А затем используйте событие ввода "onChange`, чтобы запустить наш "полный" обратный вызов. Мы видим в подписи, что "полный" ожидает "идентификатор" типа string, поэтому мы передадим ваш реквизит "идентификатор".

>  [callback function](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function) это функция, переданная в компонент в качестве реквизита.
```jsx
<input type="checkbox" checked={completed} onChange={() => complete(id)} />
```

> Обатите внимание, что параметр функции и имя реквизита просто совпадают. Этого не требуется.

Теперь, когда наши задачи запускают обратный вызов "onChange", нажмите на них и посмотрите, как реагирует приложение. Поскольку наш текст нижнего колонтитула основан на количестве непроверенных заданий, нижний колонтитул автоматически обновится, чтобы отразить новое состояние.
