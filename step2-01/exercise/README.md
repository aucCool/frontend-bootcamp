#Шаг 2.1 - Введение в TypeScript (Упражнение)

[Lessons](../../) | [Demo](../demo/) | [Final](../final/)
Если у вас еще не запущено приложение, запустите его, запустив "запуск npm" из корневой папки "frontend-bootcamp".

Упражнения будут выполнены в папке "упражнение/src" этого шага, если не указано иное. Вы также захотите открыть страницу [Упражнение Шаг 2-01](http://localhost:8080/step2-01/exercise/) чтобы видеть результаты по мере вашей работы.

## Модули

1. Откройте файл " упражнение/src/fibonacci.ts` в коде VS

2. Внутри этого файла напишите функцию под названием " fib(n)", которая принимает число и возвращает " n "-е число Фибоначчи (обязательно укажите тип " n`).

> ПОДСКАЗКА: `функция fib(n: число) { возвращает n <= 1 ? n : fib(n - 1) + fib(n - 2); }`

3. Экспортируйте `fib(n)` как **именованный экспорт**

4. Экспортируйте переменную const "FibConst" в качестве экспорта **по умолчанию**

5. Внутри "index.ts" в той же папке импортируйте как "fib", так и "FibConst" и используйте встроенную функцию console.log () для регистрации результата " fib(FibConst)".

## Типы и интерфейсы

Внутри `упражнение/src/index.ts`:

1. Добавьте псевдоним типа для типа объединения строк, описывающего состояния красно-зелено-желтого светофора: `тип светофора = ???`

2. Опишите тип автомобиля с интерфейсом: `интерфейсный автомобиль { ... }` в комплекте с " колесами`, `цветом`, `маркой`, `моделью`

3. Создайте допустимый экземпляр car и зарегистрируйте его с помощью `console.log()`: `const myCar: Car = { ??? }`;

## Обобщенные типы

Внутри `упражнение/src/stack.ts` создайте универсальный класс для "Стека<T>" в комплекте с типизированными методами " pop()` и `push ()".

> Подсказка: в массиве JavaScript уже реализованы функции "push()` и `pop ()" для вас. Это может быть ваш резервный магазин.

В "упражнении/src/index.ts "создайте" Стек<номер> "и используйте" console.log ()", чтобы продемонстрировать его функциональность.

## Распространение и разрушение

1. Обратите внимание на следующий код в index.ts:

```ts
const obj1 = {
  first: 'who',
  second: 'what',
  third: 'dunno',
  left: 'why'
};

const obj2 = {
  center: 'because',
  pitcher: 'tomorrow',
  catcher: 'today'
};
```


2. Теперь создайте однострочную строку, используя синтаксис распространения " {...x, ...y}", чтобы создать новую переменную "megaObj", которая объединяет эти два объекта.

3. Используйте синтаксис деструктурирования для извлечения значений `{первый, второй, ловец}` из `megaObj`.

## Асинхронность / ожидание

Обратите внимание на следующий код в index.ts:

```ts
function makePromise() {
  return Promise.resolve(5);
}
```

1. Вызовите функцию makePromise () с синтаксисом " ожидание` и зарегистрируйте результаты.

2. Создайте новую функцию, использующую ключевое слово "async". Внутри функции выполните вызов "ожидание` для" makePromise()` и верните результаты.
