# Шаг 2.1 - Введение в TypeScript (демонстрация)

[Уроки](../../) | [Упражнение](../упражнение/) | [Завершение](../завершение/)

На этом шаге мы рассмотрим достаточно концепций машинописи, чтобы быть продуктивными с помощью интегрированных систем React и Redux.

Темы на этом этапе будут включать:

- [Модули ES](#модули)
- [Типы](#типографские типы)
- [Распространение](#оператор распространения) и [Деструктурирование](#деструктурирование)
- [Промисы](#промисы) и [Асинхронное  ожидание](#асинхронное--ожидание)

> Чтобы опробовать концепции  TypeScript и увидеть соответствующий JavaScript, вы можете воспользоваться [игровой площадкой TypeScript](http://www.typescriptlang.org/play/index.html Мы не будем использовать его на этом тренинге, но в целом он очень удобен!

## Модули

Исторически сложилось так, что JS выполнялся только в браузере. Весь код должен был быть загружен с использованием тегов<script>. С введением node.js, сообществу JS требовался способ масштабирования, выходящий за рамки только отдельных файлов сценариев. Другие языки поддерживают понятие модулей, поэтому различные группы начали разрабатывать стандарты модульности для JS.

Наиболее важными из них, о которых следует знать, являются:

- **commonjs** - Node.js стандарт для поддержки модулей
- синхронная загрузка с использованием функции " require ()"
- `require()` может быть динамически вызван в ходе выполнения программы
- **ESM (модуль ECMAScript)** - поддержка на уровне языка
- статически анализируемый и синхронный
- динамическая и асинхронная поддержка с помощью функции " импорт ()", которая возвращает промис.

> Для получения дополнительной информации о моделях модульности и стандартах, разработанных с течением времени, см. [эту статью](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc). Вы все еще можете столкнуться с некоторыми более старыми шаблонами в устаревшем коде.

## Типы TypeScript

Ссылайтесь на [`demo/src/types`](./src/types/index.ts) для примеров некоторых типов, доступных в TS, которые приносят пользу разработчику React.

## Оператор распространения

Оператор распространения ` ... " обеспечивает быстрый способ клонирования и объединения объектов и массивов. Этот синтаксис часто встречается в реквизитах React и редукторах Redux.

С помощью **объектов**:

```ts
// Поверхностное копирование объекта
const cloned1 = { ...obj };

// Поверхностное копирование и добавление/перезапись ключа
const overridden1 = { ...obj, key: value };

// Поверхностное копирование нескольких объектов и добавление ключа
const cloned2 = { ...obj1, ...obj2, key: value };

// Используйте выражение для динамического вычисления ключа
const overridden = { ...object, [key + '-suffix']: value };
```

С **массивами**:

```ts
const copy1 = [...arr];
const copy2 = [...arr1, ...arr2];
const copyWithExtras = [123, ...arr, 'hello'];
```

Разбиение массива на позиционные аргументы функции:

```ts
function myFunc(a: number, b: number, c: number) {
  // ...
}
const arr = [1, 2, 3];
myFunc(...arr);
```

Spreading an object into props for a React component:

```jsx
const obj = { a: 1, b: 2, c: 3 };
// equivalent to:
// <MyComponent a={obj.a} b={obj.b} c={obj.c} />
const rendered = <MyComponent {...obj} />;
```

## Деструктурирование

Деструктурирование-это краткий способ извлечения свойств из объекта или массива:
```ts
const obj = { foo: 1, bar: 2 };
const { foo, bar } = obj;
// foo = 1, bar = 2

const arr = [1, 2];
const [foo, bar] = arr;
// foo = 1, bar = 2
```

Вы можете отделить элемент от остальной части объекта с помощью деструктурирования:

```ts
const obj = { a: 1, b: 2, c: 3, d: 4 };
const { a, ...rest } = obj;
// a = 1, rest = {b: 2, c: 3, d: 4}

const arr = [1, 2, 3];
const [foo, ...bar] = arr;
// foo = 1, bar = [2, 3]
```

## Промис

Промис-это объект, представляющий работу, которая будет выполнена позже, асинхронно. Промисы могут быть связаны по цепочке, что помогает при написании поддерживаемого асинхронного кода. (Как правило, устаревший асинхронный код использует обратные вызовы, чтобы позволить вызывающему абоненту контролировать, что делать после завершения задачи, что становится [очень трудным для чтения](http://callbackhell.com/).)

```ts
const aPromise = new Promise((resolve, reject) => {
  // do something async and call resolve() to let promise know it is done
  setTimeout(() => {
    // setTimeout will call this method after 1s, simulating async operation like network calls
    resolve();
  }, 1000);
});
```

Каждый экземпляр промиса предоставляет функцию " then ()`, которая может быть связана по цепочке. Он также предоставляет функцию " catch ()", которая перехватывает все исключения или вызовы " отклонить ()".:

```ts
// Promise.resolve() creates an already-resolved promise instance
const aPromise = Promise.resolve('hello world');

aPromise
  .then(result => {
    return makeAnotherPromise();
  })
  .then(result => {
    return makeYetAnotherPromise();
  })
  .catch(err => {
    console.error(err);
  });
```

> Для получения дополнительной информации см. [этот обзор промисов](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) или [это глубокое погружение](https://developers.google.com/web/fundamentals/primers/promises).
  
## Асинхронность / ожидание

**Асинхронность / Ожидание**-это функция на уровне языка для написания асинхронных функций, как если бы они были обычным синхронным кодом. Поддержка JS для этого построена поверх "Промиса" и в значительной степени вдохновлена синтаксисом асинхронности / ожидания [C#] (https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/). Асинхронная функция записывается следующим образом:

```ts
async function someFunctionAsync() {
  // Inside here, we can await on other async functions
  const result = await someOtherFunctionAsync();
  return result + ' hello';
}
```

Все функции, помеченные как "асинхронные", автоматически возвращают `Промис`. В предыдущем примере возвращалось " Промис<строка>", и его можно использовать следующим образом:
```ts
someFunctionAsync().then(result => {
  console.log(result);
});
```

> Для большей информации, смотреть [эту статью ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
