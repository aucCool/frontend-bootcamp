# Шаг 1.4 - Введение в реакцию (демонстрация)

В этой демонстрации мы создадим простой счетчик, который будет отображать количество и приращение при нажатии.

Давайте начнем демонстрацию в [CodePen](https://codepen.io/micahgodbolt/pen/wOWeVb?editors=0010).

## Реакция: "Hello World"
```js
ReactDOM.render(<p>Hello World</p>, document.getElementById('app'));
```

Вызов `ReactDOM.render () `  - это то, как наш код попадает на страницу. Функция принимает два параметра: содержимое для размещения на странице и элемент, в котором вы хотите его разместить.

Первый параметр `render()` очень похож на HTML, но на самом деле это [JSX](https://reactjs.org/docs/introducing-jsx.html). Существует несколько ключевых различий между JSX и HTML:

- Поскольку `class` - это [зарезервированное слово](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords) в JavaScript вам нужно будет использовать `className` в своих HTML-тегах: `<div className="foo">`
- Мы можем использовать пользовательские HTML-теги, соответствующие компонентам React, которые мы создаем: `<div><MyControl>hi</MyControl></div>`
- Элементы управления могут быть самозакрывающимися: `<MyControl text='hi' />`
- Вы можете использовать JavaScript внутри JSX!

## Написание компонента React

Компонент React-это фрагмент кода, который возвращает часть вашего приложения. Это может включать разметку HTML, стили CSS и функциональные возможности, управляемые JavaScript.

Компоненты могут быть созданы двумя способами. Первый метод заключается в использовании [класса JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), который расширяет (наследует от) класса `React.Сomponent`.

Классы в JavaScript предоставляют способ сбора методов (функций) и свойств (значений) в расширяемом контейнере. Мы расширяем " React.Component `, потому что он предоставляет нам несколько встроенных методов, включая `визуализацию`.

```jsx
class App extends React.Component {
  render() {
    return <p>Hello World</p>;
  }
}
```

Мы также могли бы написать этот компонент как функцию:

```jsx
const App = props => {
  return <p>Hello World</p>;
};
```

Переместив нашу разметку "Hello, World" в функцию "визуализация" вашего приложения, мы теперь можем обновить вызов " ReactDOM.render ()", чтобы он выглядел следующим образом:
```jsx
ReactDOM.render(<App />, document.getElementById('app'));
```

> Обратите внимание, что компоненты React можно использовать повторно, написав их так же, как и HTML-тег.

###  Элементы

Независимо от того, пишете ли вы компонент как класс или функцию, он может принимать дополнительные элементы, используя тот же синтаксис, что и атрибуты HTML, такие как `id` или `href`.

```jsx
<App text="Hello World" />
```

К реквизиту `text` можно получить доступ внутри вашего компонента через" props.text "в функциональном компоненте или" this.props.text " в компоненте класса.
```jsx
const App = props => {
  return <p>{props.text}</p>;
};
```

`props` позволяет вашему компоненту быть более многоразовым, так как вы можете создавать несколько экземпляров одного и того же компонента с разными реквизитами.

```jsx
ReactDOM.render(
  <div>
    <App text="Hello World" />
    <App text="How are you doing?" />
  </div>,
  document.getElementById('app')
);
```

> Обратите внимание, что функция рендеринга может возвращать только один элемент, поэтому наши два компонента "Приложения" должны быть завернуты в `div`.

```jsx
const App = props => {
  return <p>{props.text ? props.text : 'oops!'}</p>;
};
```

### Деструктурирующий элемент

Написание `props.text "снова и снова в функции (или" this.props.text " в классе) может быть довольно утомительным. Поскольку все это JavaScript, вы можете создать новую переменную для этого текста, используя назначение переменной.

```jsx
const App = props => {
  const text = props.text;
  return <p>{text ? text : 'you missed something'}</p>;
};
```

Это прекрасно работает для одного элемента, но по мере того, как ваш компонент начинает усложняться:

```jsx
<MyComponent
  open={false}
  count={5}
  text="Hi there"
  items={['cat', 'dog', 'bird']}
  config={{
    start: 1,
    end: 10,
    autoStart: true
  }}
/>
```

>Обратите внимание, что все нестроковые значения передаются как JavaScript, заключая их в `{}`.

Ваш код начинает выглядеть так:

```jsx
const open = props.open;
const text = props.text;
const count = props.count;
const items = props.items;
const start = props.config.start;
const end = props.config.end;
```

Общий подход к упрощению этого процесса заключается в использовании синтаксиса, называемого [деструктурирование](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring).

Деструктурирование позволяет извлекать отдельные фрагменты информации из объекта в одном операторе.

```jsx
const {
  open,
  text,
  count,
  items,
  config: { start, end }
} = props;
```

Так что, хотя сейчас это может быть излишним, это облегчает добавление элемента в будущем.

### Счетчик

Прежде чем мы продолжим, мы изменим наш вызов "ReactDOM.render", чтобы просто включить наше приложение. Этот вызов рендеринга обычно включает в себя только один компонент без элементов.

Далее мы создадим компонент "Counter`. Мы добавим это в наше приложение сейчас, а затем начнем писать элемент управления.

```jsx
const App = props => {
  return <Counter text="chickens" />;
};

ReactDOM.render(<App />, document.getElementById('app'));
```

> Обратите внимание на заглавную букву "Counter". HTML может быть не чувствителен к регистру, но JSX чувствителен! Общепринятой практикой является использование заглавных имен HTML-элементов для обозначения соответствующих компонентов React: Кнопка, Выбор, Метка, Форма и т.д.

## Написание компонента счетчика с отслеживанием состояния

React позволяет каждому элементу управления указывать свое собственное хранилище данных, называемое **состояние**. Мы можем ссылаться на значения в состоянии при отображении нашего пользовательского интерфейса, а также обновлять состояние в течение всего срока службы нашего приложения.

> Большинство компонентов с отслеживанием состояния, которые вы увидите сегодня, будут основаны на "классе". Совсем недавно стало возможным добавлять состояние в функциональные компоненты с помощью [`крючков`](https://reactjs.org/docs/hooks-intro.html)

### Добавление состояния

Классы JavaScript используют метод "конструктор" для создания экземпляра каждой копии класса вместе с любым применимым состоянием. Давайте создадим новый компонент под названием "Counter` и придадим ему состояние, содержащее свойство ` щелчки` со значением по умолчанию "0";

```js
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      clicks: 0
    };
  }
}
```

-Конструктор принимает `элемент`компонента.
- [`super()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) функция вызывает конструктор родительского класса (в данном случае `React.Component`).
- Наше значение состояния "клики` теперь можно получить с помощью "this.state.clicks". Позже мы сможем обновить состояние, вызвав " this.setState({ щелчки: 1 })`.

### Визуализация нашего счетчика

Для нашего компонента "Сounter" цель состоит в том, чтобы иметь возможность отслеживать, сколько раз нажата кнопка счетчика. Мы будем использовать следующую разметку.

```jsx
render() {
  const {text} = this.props;
  const {clicks} = this.state;
  return (
    <div>
      {text}: {clicks}
      <button>Click</button>
    </div>
  )
}
```

### Написание нашего обработчика нажатия кнопки

Наш следующий шаг-подключить кнопку, чтобы увеличить количество "щелчков" в состоянии нашего компонента.

> По соглашению мы помещаем другие методы ниже " render ()", а частные методы (только для внутреннего использования) имеют префикс подчеркивания.

Эта функция обновит состояние вашего компонента, увеличив значение кликов на 1. (Обратите внимание, что `setState` изменяет только значения ключей, перечисленных в объекте, переданном в качестве его параметра.)

```jsx
_onButtonClick = () => {
  this.setState({
    clicks: this.state.clicks + 1
  });
};
```

> Это не совсем метод, но свойство класса, которому присвоено значение [ arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions). Это в основном работает так же, как " onButtonClick () {}", но устраняет необходимость в [дополнительном boilerplate](https://medium.freecodecamp.org/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb) используется, чтобы избежать потенциальных "ошибок" с [как " это " работает в JavaScript](https://codeburst.io/javascript-the-keyword-this-for-beginners-fb5238d99f85).)

> Обратите внимание, что вызов "setState" также может быть записан как `this.setState(prevState => ({ clicks: prevState.clicks + 1}));", чтобы гарантировать, что состояние не обновляется до тех пор, пока не будет определено предыдущее состояние.

Теперь, когда у нас есть функция для увеличения нашего количества, все, что осталось, - это подключить ее к нашей кнопке.

```jsx
<button onClick={this._onButtonClick}>Click</button>
```

> Также обратите внимание, что каждый "Counter` поддерживает свое собственное состояние! Вы можете изменить состояние внутри одного счетчика, не влияя на другие.

## Попробуйте все это!

Добавьте пару "Сounter" в наше "приложение", каждый с разным текстом. Обратите внимание, как они могут легко принимать различные опоры и поддерживать свое собственное состояние.

## Перенос этого в нашу кодовую базу

Чтобы масштабировать наше приложение, нам нужно будет разбить файл на более мелкие, повторно используемые части. В этой части демонстрации мы рассмотрим "последнюю" папку и то, как система модулей JavaScript позволяет нам разбивать наши компоненты на набор файлов, экспортирующих их функциональность.

### Экспорт и импорт модулей

Откройте `step1-04/final/components/Counter.tsx` и посмотрите на компонент `Counter`.

```tsx
export class Counter extends React.Component {
  // ...
}
```

Этот файл экспортирует компонент счетчика в виде **с именем экспорт**. Это означает, что при импорте мы делаем следующее:

```tsx
import { Counter } from './components/Counter';
```

> Обратите внимание на " {}`, расположенное  вокруг значения импорта. На самом деле это пример деструктурирования.

#### Экспорт по умолчанию

Обычно мы используем именованный экспорт, но также возможно экспортировать значение по умолчанию, подобное этому:

```tsx
export default class Counter extends React.Component {
  // ...
}
```

Когда мы импортируем компонент, мы можем называть его как угодно:

```tsx
import SomeCounterComponent from './components/Counter';
```

## Написание компонента кнопки

Кнопки являются одними из наиболее часто пишущихся компонентов. Пользовательские кнопки помогают абстрагироваться от общего стиля, добавлять значки или другие украшения, а также расширять функциональность (кнопки меню и т.д.). Давайте быстро взглянем на пользовательский компонент кнопки, чтобы увидеть, как он сочетается.
```jsx
import React from 'react';
import './Button.css';

export const Button = props => {
  return (
    <button className="Button" onClick={props.onClick}>
      {props.children}
    </button>
  );
};
```
