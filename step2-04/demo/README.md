# Шаг 2.4 - Контекст реакции (Демонстрация)
[Уроки](../../) | [Упражнение](../упражнение/)

На этом шаге мы опишем некоторые проблемы, с которыми мы сталкиваемся при создании более сложного приложения.

Мы решим эти проблемы с помощью [React Context API](https://reactjs.org/docs/context.html). Контекстный API состоит из компонентов Поставщика и Потребителя. Давайте взглянем на то, что находится на этом шаге:

1. Проблема сложных приложений
2. Прикладной программный интерфейс контекста реакции
3. Использование контекста из компонента класса
4. Использование контекста из функционального компонента

## Проблема сложных приложений

React представляет собой один такой компонент:
```
(props) => view;
```

В реальном приложении эти функции составлены. Это больше похоже на это:

![](../../assets/todo-components.png)

Возможность создавать компоненты полезна, но она создает некоторые сложности:

1. Данные должны передаваться от компонента к компоненту с помощью реквизитов-даже если некоторым промежуточным компонентам не нужно знать о некоторых данных. Это проблема, называемая **бурение реквизита**.

2. Общие данные могут быть изменены различными участниками (взаимодействие с пользователем, обновления с сервера), и координация этих изменений отсутствует. Это затрудняет распространение обновлений между компонентами.

Даже в нашем простом приложении мы увидели эту проблему. Например, " <ToDoList>` имеет этот интерфейс реквизитов:

```ts
interface TodoListProps {
  complete: (id: string) => void;
  remove: (id: string) => void;
  todos: Store['todos'];
  filter: FilterTypes;
  edit: (id: string, label: string) => void;
}
```

Ни один из этих реквизитов не используется в самом "ToDoList"; они передаются только дочерним компонентам "TodoListItem".:

```js
<TodoListItem todos="{todos}" complete="{complete}" remove="{remove}" edit="{edit}" />
```

## Прикладной программный интерфейс контекста реакции. 

Давайте решим эти проблемы с помощью [Прикладного программного интерфейса контекста реакции](https://reactjs.org/docs/context.html). Контекст-это способ обмена данными из компонентов с их дочерними компонентами без явной передачи их через реквизиты на каждом уровне дерева. Проще говоря, это решает проблему разборки задачи, упомянутую выше!

Контекст реакции создается вызовом `createContext()`  с некоторыми исходными данными. Используйте компонент `<TodoContext.Provider>` чтобы перенести  часть составляющих компонента, которая должна быть передана контексту.
  
### Предоставление контекста с `<TodoContext.Provider>`

```js
// To create an empty context
const TodoContext = React.createContext(undefined);

class TodoApp extends React.Component {
  render() {
    // Передайте некоторые состояния и функции в ценностное предложение провайдера
    return (
      <TodoContext.Provider
        value={{
          ...this.state,
          addTodo: this._addTodo,
          setFilter: this._setFilter,
          /* same goes for remove, complete, and clear */
        }}>
        <div>
          <TodoHeader />
          <TodoList />
          <TodoFooter />
        </div>
      </TodoContext.Provider>
    );
  }
}
```

### Использование контекста из компонента класса

Внутри дочернего компонента на основе класса, такого как "< ЗаголовокTo do>", контекст, созданный в родительском, может быть доступен через " this.context`. Обратите внимание, что для того, чтобы это сработало, вы также должны задать свойству класса компонента `contextType`, тип контекста, созданный выше.
```js
class TodoHeader extends React.Component {
  render() {
    // Step 1: use the context prop
    return <div>Filter is {this.context.filter}</div>;
  }
}

// Step 2: be sure to set the contextType property of the component class
TodoHeader.contextType = TodoContext;
```

### Использование контекста из функционального компонента

Если вы используете синтаксис функционального компонента, вы можете получить доступ к контексту с помощью крючка `useContext()` :

```js
const TodoFooter = props => {
  const context = useContext(TodoContext);
  return (
    <div>
      <button onClick={context.clear()}>Clear Completed</button>
    </div>
  );
};
```

> Заметьте, что `useContext()` требует недавний выпуск React (16.8+)

Существует другой юридический синтаксис для доступа к контексту с помощью `<TodoContext.Consumer>`, но мы оставим это в качестве упражнения для вас!
