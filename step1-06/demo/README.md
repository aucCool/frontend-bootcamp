# Шаг 1.6 - Создание пользовательского интерфейса, управляемого состоянием (демонстрация)
В React, данные перемещаются в одном направлении: сверху вниз в виде состояния, распространяющегося по иерархии компонентов. Только компонент, содержащий состояние, может изменить само состояние. Когда происходит взаимодействие с пользовательским интерфейсом, компонент с отслеживанием состояния должен передать обработчик событий компоненту пользовательского интерфейса, запускающему событие, чтобы сигнализировать об изменении состояния.
[Шаг №3 "Мышление в реакции"](https://reactjs.org/docs/thinking-in-react.html) предлагает найти "минимальный набор изменяемых состояний", который требуется вашему приложению. Поэтому в этой демонстрации мы собираемся добавить это "минимальное состояние" в наше приложение и удалить наш пользовательский интерфейс из этих данных. После этого следующим шагом будет создание способов изменения этого состояния, которые, в свою очередь, будут каскадно передаваться через наш пользовательский интерфейс. Это [примирение](https://reactjs.org/docs/reconciliation.html) процесс, выясняющий, что в вашем пользовательском интерфейсе должно измениться в зависимости от изменения состояния, - это то, в чем React превосходит.
## Добавление состояния в приложение TodoApp

Внутри нашего класса `TodoApp` мы добавим минимальное состояние для нашего приложения, которое включает в себя всего два ключа: "todos" и "фильтр". Нам не нужно беспокоиться о количестве "оставшихся", потому что его можно рассчитать, подсчитав количество заданий, в которых поле "завершено" имеет значение "ложь".

Итак, вот наша полная конструкция:
```jsx
constructor(props) {
  super(props);
  this.state = {
    todos: {
      '04': {
        label: 'Todo 4',
        completed: true
      },
      '03': {
        label: 'Todo 3',
        completed: false
      },
      '02': {
        label: 'Todo 2',
        completed: false
      },
      '01': {
        label: 'Todo 1',
        completed: false
      }
    },
    filter: 'active'
  };
}
```

> Вы также можете использовать массив для представления ваших задач. В некоторых случаях манипулирование массивами может быть проще, но этот объектный подход упрощает другие функции и в конечном итоге будет более эффективным.

## Передача состояния в пользовательский интерфейс

Теперь мы можем передать " фильтр` и `задачи` в наши компоненты.

```jsx
render() {
  const { filter, todos } = this.state;
  return (
    <div>
      <TodoHeader filter={filter} />
      <TodoList todos={todos} filter={filter} />
      <TodoFooter todos={todos} />
    </div>
  );
}
```

## Список задач, управляемых Todo

Я уже вытащил наши реквизиты в переменные "фильтр" и "задачи" и написал немного JS, который вернет массив отфильтрованных идентификаторов задач. Мы будем использовать этот отфильтрованный массив для визуализации наших задач.

> `todos[id]` возвращает задание, соответствующее переданному идентификатору, и оператор распространения (...) совпадает со словами `label={todos[id].label} completed={todos[id].completed}`

```jsx
return (
  <ul className="todos">
    {filteredTodos.map(id => (
      <TodoListItem key={id} id={id} {...todos[id]} />
    ))}
  </ul>
);
```

## Заголовок задачи, управляемый состоянием и с учетом состояния

В заголовке у нас есть ситуация, когда мы не только хотим передать ему состояние "фильтр", но также хотим сохранить состояние в элементе управления. К счастью, для React это вообще не проблема. Во-первых, давайте разберемся с входящим состоянием.

### Условные имена классов

В стиле на основе CSS визуальные состояния применяются путем добавления и удаления классов. Мы можем использовать значение фильтра для условного добавления класса, тем самым освещая правильную кнопку фильтра.
```jsx
<nav className="filter">
  <button className={filter === 'all' ? 'selected' : ''}>all</button>
  <button className={filter === 'active' ? 'selected' : ''}>active</button>
  <button className={filter === 'completed' ? 'selected' : ''}>completed</button>
</nav>
```

> [Троичный operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) `состояние ? expressionIfTrue : expressionIfFalse` широко используется в коде React, так как каждое выражение может быть строкой для имени класса или даже элемента JSX.

### Добавление управляемого ввода

В React элементы формы, такие как " <ввод>", "<область текста> " и " <выбор>", могут использоваться как **неконтролируемые** или **контролируемые**.

**Неконтролируемый ввод** сохраняет свое текущее значение внутри и обновляет его на основе взаимодействия с пользователем (ввод текста, выбор параметров и т.д.). Код извлекает значение из входных данных только тогда, когда это необходимо, например, при отправке. Это похоже на то, как работают входные данные в простой HTML-форме.

**Управляемый ввод** принимает свое текущее значение из опоры и использует обратный вызов для уведомления родительского компонента об изменениях, внесенных пользователем. Значение ввода не изменится до тех пор, пока родительский компонент не обновит реквизиты ввода в ответ на обратный вызов.

> Различие между контролируемым и неконтролируемым важно понимать при написании или использовании компонентов формы, и неправильное понимание этой концепции является очень распространенным источником ошибок. См. [эту статью](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/) для более подробного объяснения.

Давайте попробуем изменить текстовое поле в нашем компоненте "TodoHeader" на управляемый ввод. Чтобы добавить контролируемый ввод, нам нужны две вещи, которые уже есть в нашей демо-версии:
1. Переменная состояния для хранения входного значения:
```jsx
this.state = { labelInput: '' };
```

2. Функция обратного вызова для обновления этого значения:
```jsx
_onChange = evt => {
  this.setState({ labelInput: evt.target.value });
};
```

Имея эти две части на месте, мы можем обновить наш неконтролируемый ввод, чтобы его можно было контролировать.

```jsx
<input value={this.state.labelInput} onChange={this._onChange} className="textfield" placeholder="add todo" />
```

>Если у вас установлены инструменты разработки React, откройте их и посмотрите на "Ввод метки", когда мы вводим в поле ввода.
